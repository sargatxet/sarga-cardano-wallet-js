/* tslint:disable */
/* eslint-disable */
/**
 * Cardano Wallet Backend API
 * <p align=\"right\"><img style=\"position: relative; top: -10em; margin-bottom: -12em;\" width=\"20%\" src=\"https://cardanodocs.com/img/cardano.png\"></img></p>
 *
 * OpenAPI spec version: 2021.3.4
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError
} from '../base'
import { ApiPostTransactionFeeData } from '../models'
import { ApiPostTransactionData } from '../models'
import { ApiTransaction } from '../models'
import { ApiFee } from '../models'
import { InlineResponse400 } from '../models'
import { InlineResponse4001 } from '../models'
import { InlineResponse4031 } from '../models'
import { InlineResponse4032 } from '../models'
import { InlineResponse404 } from '../models'
import { NoSuchWallet } from '../models'
import { NotAcceptable } from '../models'
import { TransactionAlreadyInLedger } from '../models'
import { UnsupportedMediaType } from '../models'
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Forget pending transaction. Importantly, a transaction, when sent, cannot be cancelled. One can only request forgetting about it in order to try spending (concurrently) the same UTxO in another transaction. But, the transaction may still show up later in a block and therefore, appear in the wallet.
     * @summary Forget
     * @param {string} walletId
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction: async (
      walletId: string,
      transactionId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling deleteTransaction.'
        )
      }
      // verify required parameter 'transactionId' is not null or undefined
      if (transactionId === null || transactionId === undefined) {
        throw new RequiredError(
          'transactionId',
          'Required parameter transactionId was null or undefined when calling deleteTransaction.'
        )
      }
      const localVarPath = `/wallets/{walletId}/transactions/{transactionId}`
        .replace(`{${'walletId'}}`, encodeURIComponent(String(walletId)))
        .replace(
          `{${'transactionId'}}`,
          encodeURIComponent(String(transactionId))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      const query = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        query.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(query).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Get transaction by id.
     * @summary Get
     * @param {string} walletId
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction: async (
      walletId: string,
      transactionId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling getTransaction.'
        )
      }
      // verify required parameter 'transactionId' is not null or undefined
      if (transactionId === null || transactionId === undefined) {
        throw new RequiredError(
          'transactionId',
          'Required parameter transactionId was null or undefined when calling getTransaction.'
        )
      }
      const localVarPath = `/wallets/{walletId}/transactions/{transactionId}`
        .replace(`{${'walletId'}}`, encodeURIComponent(String(walletId)))
        .replace(
          `{${'transactionId'}}`,
          encodeURIComponent(String(transactionId))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      const query = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        query.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(query).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Lists all incoming and outgoing wallet's transactions.
     * @summary List
     * @param {string} walletId
     * @param {string} [start] An optional start time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
     * @param {string} [end] An optional end time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
     * @param {string} [order] An optional sort order.
     * @param {number} [minWithdrawal] Returns only transactions that have at least one withdrawal above the given amount. This is particularly useful when set to &#x60;1&#x60; in order to list the withdrawal history of a wallet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactions: async (
      walletId: string,
      start?: string,
      end?: string,
      order?: string,
      minWithdrawal?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling listTransactions.'
        )
      }
      const localVarPath = `/wallets/{walletId}/transactions`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (start !== undefined) {
        localVarQueryParameter['start'] = start
      }

      if (end !== undefined) {
        localVarQueryParameter['end'] = end
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order
      }

      if (minWithdrawal !== undefined) {
        localVarQueryParameter['minWithdrawal'] = minWithdrawal
      }

      const query = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        query.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(query).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Create and send transaction from the wallet.
     * @summary Create
     * @param {ApiPostTransactionData} body
     * @param {string} walletId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransaction: async (
      body: ApiPostTransactionData,
      walletId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling postTransaction.'
        )
      }
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling postTransaction.'
        )
      }
      const localVarPath = `/wallets/{walletId}/transactions`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const query = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        query.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(query).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Estimate fee for the transaction. The estimate is made by assembling multiple transactions and analyzing the distribution of their fees. The estimated_max is the highest fee observed, and the estimated_min is the fee which is lower than at least 90% of the fees observed.
     * @summary Estimate Fee
     * @param {ApiPostTransactionFeeData} body
     * @param {string} walletId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransactionFee: async (
      body: ApiPostTransactionFeeData,
      walletId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling postTransactionFee.'
        )
      }
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling postTransactionFee.'
        )
      }
      const localVarPath = `/wallets/{walletId}/payment-fees`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const query = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        query.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(query).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Forget pending transaction. Importantly, a transaction, when sent, cannot be cancelled. One can only request forgetting about it in order to try spending (concurrently) the same UTxO in another transaction. But, the transaction may still show up later in a block and therefore, appear in the wallet.
     * @summary Forget
     * @param {string} walletId
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTransaction(
      walletId: string,
      transactionId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(
        configuration
      ).deleteTransaction(walletId, transactionId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Get transaction by id.
     * @summary Get
     * @param {string} walletId
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransaction(
      walletId: string,
      transactionId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransaction>
    > {
      const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(
        configuration
      ).getTransaction(walletId, transactionId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Lists all incoming and outgoing wallet's transactions.
     * @summary List
     * @param {string} walletId
     * @param {string} [start] An optional start time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
     * @param {string} [end] An optional end time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
     * @param {string} [order] An optional sort order.
     * @param {number} [minWithdrawal] Returns only transactions that have at least one withdrawal above the given amount. This is particularly useful when set to &#x60;1&#x60; in order to list the withdrawal history of a wallet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactions(
      walletId: string,
      start?: string,
      end?: string,
      order?: string,
      minWithdrawal?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ApiTransaction>>
    > {
      const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(
        configuration
      ).listTransactions(walletId, start, end, order, minWithdrawal, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Create and send transaction from the wallet.
     * @summary Create
     * @param {ApiPostTransactionData} body
     * @param {string} walletId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTransaction(
      body: ApiPostTransactionData,
      walletId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransaction>
    > {
      const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(
        configuration
      ).postTransaction(body, walletId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Estimate fee for the transaction. The estimate is made by assembling multiple transactions and analyzing the distribution of their fees. The estimated_max is the highest fee observed, and the estimated_min is the fee which is lower than at least 90% of the fees observed.
     * @summary Estimate Fee
     * @param {ApiPostTransactionFeeData} body
     * @param {string} walletId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTransactionFee(
      body: ApiPostTransactionFeeData,
      walletId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiFee>
    > {
      const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(
        configuration
      ).postTransactionFee(body, walletId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        }
        return axios.request(axiosRequestArgs)
      }
    }
  }
}

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Forget pending transaction. Importantly, a transaction, when sent, cannot be cancelled. One can only request forgetting about it in order to try spending (concurrently) the same UTxO in another transaction. But, the transaction may still show up later in a block and therefore, appear in the wallet.
     * @summary Forget
     * @param {string} walletId
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(
      walletId: string,
      transactionId: string,
      options?: any
    ): AxiosPromise<void> {
      return TransactionsApiFp(configuration)
        .deleteTransaction(walletId, transactionId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Get transaction by id.
     * @summary Get
     * @param {string} walletId
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      walletId: string,
      transactionId: string,
      options?: any
    ): AxiosPromise<ApiTransaction> {
      return TransactionsApiFp(configuration)
        .getTransaction(walletId, transactionId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Lists all incoming and outgoing wallet's transactions.
     * @summary List
     * @param {string} walletId
     * @param {string} [start] An optional start time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
     * @param {string} [end] An optional end time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
     * @param {string} [order] An optional sort order.
     * @param {number} [minWithdrawal] Returns only transactions that have at least one withdrawal above the given amount. This is particularly useful when set to &#x60;1&#x60; in order to list the withdrawal history of a wallet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactions(
      walletId: string,
      start?: string,
      end?: string,
      order?: string,
      minWithdrawal?: number,
      options?: any
    ): AxiosPromise<Array<ApiTransaction>> {
      return TransactionsApiFp(configuration)
        .listTransactions(walletId, start, end, order, minWithdrawal, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Create and send transaction from the wallet.
     * @summary Create
     * @param {ApiPostTransactionData} body
     * @param {string} walletId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransaction(
      body: ApiPostTransactionData,
      walletId: string,
      options?: any
    ): AxiosPromise<ApiTransaction> {
      return TransactionsApiFp(configuration)
        .postTransaction(body, walletId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * <p align=\"right\">status: <strong>stable</strong></p>  Estimate fee for the transaction. The estimate is made by assembling multiple transactions and analyzing the distribution of their fees. The estimated_max is the highest fee observed, and the estimated_min is the fee which is lower than at least 90% of the fees observed.
     * @summary Estimate Fee
     * @param {ApiPostTransactionFeeData} body
     * @param {string} walletId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransactionFee(
      body: ApiPostTransactionFeeData,
      walletId: string,
      options?: any
    ): AxiosPromise<ApiFee> {
      return TransactionsApiFp(configuration)
        .postTransactionFee(body, walletId, options)
        .then((request) => request(axios, basePath))
    }
  }
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
  /**
   * <p align=\"right\">status: <strong>stable</strong></p>  Forget pending transaction. Importantly, a transaction, when sent, cannot be cancelled. One can only request forgetting about it in order to try spending (concurrently) the same UTxO in another transaction. But, the transaction may still show up later in a block and therefore, appear in the wallet.
   * @summary Forget
   * @param {string} walletId
   * @param {string} transactionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public deleteTransaction(
    walletId: string,
    transactionId: string,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration)
      .deleteTransaction(walletId, transactionId, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * <p align=\"right\">status: <strong>stable</strong></p>  Get transaction by id.
   * @summary Get
   * @param {string} walletId
   * @param {string} transactionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public getTransaction(
    walletId: string,
    transactionId: string,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration)
      .getTransaction(walletId, transactionId, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * <p align=\"right\">status: <strong>stable</strong></p>  Lists all incoming and outgoing wallet's transactions.
   * @summary List
   * @param {string} walletId
   * @param {string} [start] An optional start time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
   * @param {string} [end] An optional end time in ISO 8601 date-and-time format. Basic and extended formats are both accepted. Times can be local (with a timezone offset) or UTC.  If both a start time and an end time are specified, then the start time must not be later than the end time.  Example: &#x60;2008-08-08T08:08:08Z&#x60;
   * @param {string} [order] An optional sort order.
   * @param {number} [minWithdrawal] Returns only transactions that have at least one withdrawal above the given amount. This is particularly useful when set to &#x60;1&#x60; in order to list the withdrawal history of a wallet.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public listTransactions(
    walletId: string,
    start?: string,
    end?: string,
    order?: string,
    minWithdrawal?: number,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration)
      .listTransactions(walletId, start, end, order, minWithdrawal, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * <p align=\"right\">status: <strong>stable</strong></p>  Create and send transaction from the wallet.
   * @summary Create
   * @param {ApiPostTransactionData} body
   * @param {string} walletId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public postTransaction(
    body: ApiPostTransactionData,
    walletId: string,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration)
      .postTransaction(body, walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }
  /**
   * <p align=\"right\">status: <strong>stable</strong></p>  Estimate fee for the transaction. The estimate is made by assembling multiple transactions and analyzing the distribution of their fees. The estimated_max is the highest fee observed, and the estimated_min is the fee which is lower than at least 90% of the fees observed.
   * @summary Estimate Fee
   * @param {ApiPostTransactionFeeData} body
   * @param {string} walletId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public postTransactionFee(
    body: ApiPostTransactionFeeData,
    walletId: string,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration)
      .postTransactionFee(body, walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
